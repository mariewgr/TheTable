import { AsyncAction, SimpleSyncAction, SyncAction, StoreAction, AsyncActionPromise, AsyncActionPromiseGet, PromiseProvider, DecoratedActions, InternalLoadingMap, StoreOptions, InvocationContextActions, OnMountInvocationContext, OnPropsChangeEffectsContext, ContextState, Middleware, MiddlewareFactory, ContextWithDerived, PromiseIdErrorMap, ErrorMap, ErrorParallelMap, OnUnMountInvocationContext, AbortedActions, ClearErrorFunc, StoreConfig, StoreConfigFunc } from './types';
export type SetStateFunc<S, A> = (newState: S, newLoadingMap: InternalLoadingMap<A>, actionName: keyof A | 'onPropsChange', actionType: 'preEffects' | 'effects' | 'errorEffects' | null, // FIXME
isAsync: boolean, actionCtx: any, propsChanged: boolean, isInit?: boolean) => void;
/** @internal */
export type PromiseMap<A> = {
    [name in keyof A]?: {
        [promiseId: string]: {
            promise: Promise<any>;
            refArgs: any[];
            abortController: AbortController;
        };
    };
};
/** @internal */
export type FutureActions = {
    args: any[];
    resolve: (...args: any[]) => void;
    reject: (...args: any[]) => void;
    timestamp?: number;
};
/** @internal */
export type ConflictActionsMap<A> = {
    [name in keyof A]?: FutureActions[];
};
/** @internal */
export type AsyncActionExecContext<S, DS, F extends (...args: any[]) => any, A extends DecoratedActions, P> = {
    actionName: keyof A;
    action: AsyncActionPromise<S, F, A, P, DS>;
    stateRef: Ref<S>;
    derivedStateRef: Ref<DerivedState<DS>>;
    propsRef: Ref<P>;
    loadingParallelMapRef: Ref<InternalLoadingMap<A>>;
    errorMapRef: Ref<ErrorParallelMap<A>>;
    promisesRef: Ref<PromiseMap<A>>;
    conflictActionsRef: Ref<ConflictActionsMap<A>>;
    actionsRef: Ref<A>;
    initializedRef: Ref<boolean>;
    options: StoreOptions<S, A, P, any>;
    setState: SetStateFunc<S, A>;
    clearError: ClearErrorFunc<A>;
};
/** @internal */
export type TimeoutMap<A> = {
    [name in keyof A]?: any;
};
export type NotifyFunc = (msg: string) => void;
export type CloneFunction = <C>(obj: C) => C;
export type ComparatorFunction = <C>(obj1: C, Obj2: C) => boolean;
export type RetryOnErrorFunction = (error: any) => boolean;
export type AsyncErrorHandler = (error: any, isHandled: boolean, state: any, props: any, actionName: string, args: any[]) => void;
type DerivedStateMap<DS> = {
    [name in keyof DS]?: any[];
};
/** @internal */
export type DerivedState<DS> = {
    state: DS;
    deps: DerivedStateMap<DS>;
};
export declare class EffectError extends Error {
    /**
     * The wrapped error
     */
    source: any;
    /**
     * If effects error occurred while processed an error, the initial error.
     */
    initialError: Error;
    constructor(source: any, initialError?: Error);
}
/**
 * Global configuration, shared with all stores.
 */
export type GlobalConfig = {
    /**
     * Clone function.
     * Used to clone state and props when managing optimistic reducer and conflicting actions.
     * Default implementation is a very basic algorithm using JSON.stringify. To clone complex stats,
     * use a custom implementation like lodash/cloneDeep.
     * @default JSON.stringify
     */
    clone: CloneFunction;
    /**
     * Compare to objets and returns if they are equal.
     * Used to comparent previous and current state slice.
     * @default shallow
     */
    comparator: ComparatorFunction;
    /**
     * Global callback function to handle asychronous actions rejected promise.
     */
    asyncErrorHandler: AsyncErrorHandler;
    /**
     * Tests if the error will trigger a retry of the action or will fail directly.
     * Default implementation is returning true for TypeError instances only.
     * @see AsynchActionBase#retryCount
     */
    retryOnErrorFunction: RetryOnErrorFunction;
    /**
     * Global notification function that will called when an asynchronous action succeeded,
     * if and only if, an error message is specified for this action using
     * <code>getErrorMessage</code>.
     * If another function is set in the options, the function from the options will be used.
     */
    notifySuccess: NotifyFunc;
    /**
     * Global notification function that will called when an asynchronous action fails,
     * if and only if, an error message is specified for this action using
     * <code>getErrorMessage</code>.
     * If another function is set in the options, the function from the options will be used.
     */
    notifyError: NotifyFunc;
    /**
     * Global notification function that will injected in onDone and onFail of an asynchronous actions and onActionDone of a synchronous function,
     * If another function is set in the options, the function from the options will be used.
     */
    notifyWarning: NotifyFunc;
    /**
     * A default error message provider.
     * Used to return generic messages on generic HTTP errors
     */
    getErrorMessage: (error: Error) => string;
    /**
     * Default middlewares. Store middleware array will be concatenated with this one.
     * By default contains only the optimistic middleware.
     */
    defaultMiddlewares: MiddlewareFactory<any, any, any>[];
};
/** @internal */
export declare const globalConfig: GlobalConfig;
export declare function setGlobalConfig(overrideConfig: Partial<GlobalConfig>): void;
/**
 * Type guard function to test if an action is a asynchronous action.
 */
export declare function isAsyncAction<S, DS, F extends (...args: any[]) => any, A, P, FxRes = S>(action: StoreAction<S, F, A, P, DS, FxRes>): action is AsyncAction<S, F, A, P, DS, FxRes>;
/**
 * Type guard function to test if an action is a synchronous action.
 */
export declare function isSimpleSyncAction<S, F extends (...args: any[]) => any, A, P, DS = {}, FxRes = S>(action: StoreAction<S, F, A, P, DS, FxRes>): action is SimpleSyncAction<S, F, P, DS, FxRes>;
/**
 * Type guard function to test if an action is a synchronous action.
 */
export declare function isSyncAction<S, F extends (...args: any[]) => any, A, P, DS = {}, FxRes = S>(action: StoreAction<S, F, A, P, DS, FxRes>): action is SyncAction<S, F, A, P, DS, FxRes>;
export declare function isAsyncGetPromiseAction<S, DS, F extends (...args: any[]) => any, A, P, FxRes = S>(action: StoreAction<S, F, A, P, DS, FxRes>): action is AsyncActionPromise<S, F, A, P, DS, FxRes>;
export declare function isAsyncGetPromiseGetAction<S, DS, F extends (...args: any[]) => any, A, P, FxRes = S>(action: StoreAction<S, F, A, P, DS, FxRes>): action is AsyncActionPromiseGet<S, F, A, P, DS, FxRes>;
/** @internal */
export declare function computeAsyncActionInput<S, DS, F extends (...args: any[]) => any, A, P, FxRes = S>(action: AsyncAction<S, F, A, P, DS, FxRes>): AsyncActionPromise<S, F, A, P, DS, FxRes>;
/** @internal */
export declare function buildLoadingMap<A>(source: InternalLoadingMap<A>, actionName: keyof A, promiseId: string, loading: boolean): InternalLoadingMap<A>;
/** @internal */
export declare function updateErrorMap<A>(source: ErrorParallelMap<A>, actionName: keyof A, promiseId: string, error: Error): ErrorParallelMap<A>;
export declare class ParallelActionError extends Error {
    promiseIds: PromiseIdErrorMap;
    constructor(promiseIds: PromiseIdErrorMap);
}
export declare function buildErrorMap<A>(map: ErrorParallelMap<A>): ErrorMap<A>;
/** @internal */
export declare function retryPromiseDecorator<S, DS, F extends (...args: any[]) => Promise<any>, A, P>(promiseProvider: PromiseProvider<S, DS, F, A, P>, maxCalls?: number, delay?: number, isRetryError?: (e: Error) => boolean): PromiseProvider<S, DS, F, A, P>;
export type Ref<P> = {
    current: P;
};
/** @internal */
export declare function createRef<U>(init?: U): Ref<U>;
/** @internal */
export declare function buildInvocationContextBase<S, DS, P>(stateRef: Ref<S>, derivedStateRef: Ref<DerivedState<DS>>, propsRef: Ref<P>): ContextWithDerived<S, DS, P>;
/** @internal */
export declare function buildOnMountInvocationContext<S, DS, A, P>(stateRef: Ref<S>, derivedStateRef: Ref<DerivedState<DS>>, propsRef: Ref<P>, actionsRef: Ref<A>): OnMountInvocationContext<S, A, P>;
/** @internal */
export declare function buildOnUnMountInvocationContext<S, DS, A, P>(stateRef: Ref<S>, derivedStateRef: Ref<DerivedState<DS>>, propsRef: Ref<P>, abortedActions: AbortedActions<A>): OnUnMountInvocationContext<S, A, P>;
/** @internal */
export declare function buildOnPropChangeEffects<S, DS, P>(stateRef: Ref<S>, derivedStateRef: Ref<DerivedState<DS>>, propsRef: Ref<P>, indices: number[], index: number, isInit: boolean, getInitialState: (p: P) => S): OnPropsChangeEffectsContext<S, DS, P>;
/** @internal */
export declare function addStateToContext<T, S>(ctx: T, stateRef: Ref<S>): T & ContextState<S>;
/** @internal */
export declare function addContextActions<T, A>(ctx: T, actionsRef: Ref<A>): T & InvocationContextActions<A>;
/** @internal */
export declare function isFuncConfig<S, A extends DecoratedActions, P = {}, DS = {}>(config: StoreConfig<S, A, P, DS>): config is StoreConfigFunc<S, A, P, DS>;
/** @internal */
export declare function decorateSimpleSyncAction<S, DS, F extends (...args: any[]) => any, A extends DecoratedActions, P>(actionName: keyof A, action: SimpleSyncAction<S, F, P, DS>, stateRef: Ref<S>, derivedStateRef: Ref<DerivedState<DS>>, propsRef: Ref<P>, initializedRef: Ref<boolean>, options: StoreOptions<S, A, P, DS>, setState: SetStateFunc<S, A>): (...args: Parameters<F>) => void;
/** @internal */
export declare function decorateSyncAction<S, DS, F extends (...args: any[]) => any, A extends DecoratedActions, P>(actionName: keyof A, action: SyncAction<S, F, A, P, DS>, stateRef: Ref<S>, derivedStateRef: Ref<DerivedState<DS>>, propsRef: Ref<P>, actionsRef: Ref<A>, initializedRef: Ref<boolean>, timeoutMap: Ref<TimeoutMap<A>>, options: StoreOptions<S, A, P, any>, setState: SetStateFunc<S, A>, clearError: ClearErrorFunc<A>): (...args: Parameters<F>) => void;
/** @internal */
export declare function decorateAsyncAction<S, DS, F extends (...args: any[]) => any, A extends DecoratedActions, P>(context: AsyncActionExecContext<S, DS, F, A, P>): (...args: Parameters<F>) => Promise<any>;
/** @internal */
export declare function isLoadingImpl<A, K extends keyof A>(loadingMap: InternalLoadingMap<A>, ...props: (K | [K, string])[]): boolean;
export declare const DEFAULT_PROMISE_ID = "__def__";
/** @internal */
export declare function areSameArgs(args1: any[], args2: any[]): boolean;
/** @internal */
export declare function computeDerivedValues<S, A, P, DS>(s: Ref<S>, p: Ref<P>, derivedStateRef: Ref<DerivedState<DS>>, options: StoreOptions<S, A, P, DS>): boolean;
/** @internal */
export declare function fixDerivedDeps<S, A, P, DS>(options: StoreOptions<S, A, P, DS>): void;
/** @internal */
export declare function onPropChange<S, P, A, DS>(stateRef: Ref<S>, derivedStateRef: Ref<DerivedState<DS>>, propsRef: Ref<P>, oldProps: P, actionsRef: Ref<A>, options: StoreOptions<S, A, P, DS>, getInitialState: (p: P) => S, setState: SetStateFunc<S, A>, isInit: boolean, isDeferred: boolean): void;
/** @internal */
export declare function runMiddlewares<S, A extends DecoratedActions, P>(middlewares: Middleware<S, A, P>[], oldState: S, newState: S, loading: boolean, actionName: keyof A, actionType: 'preEffects' | 'effects' | 'errorEffects' | null, isAsync: boolean, actionCtx: any): {
    newState: S;
    newLoading: boolean;
};
export {};
