import { ErrorMap, StoreActions, StoreApi, StoreOptions } from '.';
import { DerivedState, SetStateFunc, Ref } from './impl';
import { DecoratedActions, StoreConfig } from './types';
type MockActions<A, MockAction> = {
    [k in keyof A]: MockAction;
};
type MockResult<S, A extends DecoratedActions, P, DS> = {
    readonly prevState: S & DS;
    readonly state: S & DS;
    readonly props: P;
    readonly actions: MockActions<A, any>;
    readonly errorMap: ErrorMap<A>;
};
type MockActionImpl<A> = Partial<Record<keyof A, (...args: any[]) => any>>;
type MockResultWithTest<S, A extends DecoratedActions, P, DS> = MockResult<S, A, P, DS> & {
    /**
     * Execute function passed as parameter to test state/props/actions called.
     */
    test: (f: (res: MockResult<S, A, P, DS>) => void) => void;
};
type MockStoreAction<S, A extends DecoratedActions, F extends (...args: any[]) => any, P, DS> = {
    /**
     * Creates a new store action with specified state.
     */
    setState: (state: S) => MockStoreAction<S, A, F, P, DS>;
    /**
     * Creates a new store action with specified props.
     */
    setProps: (props: P) => MockStoreAction<S, A, F, P, DS>;
    /**
     * Creates a new store action using store state overriden by specified state.
     */
    setPartialState: (state: Partial<S>) => MockStoreAction<S, A, F, P, DS>;
    /**
     * Creates a new store action using store props overriden by specified props.
     */
    setPartialProps: (props: Partial<P>) => MockStoreAction<S, A, F, P, DS>;
    /**
     * Set implementations to some actions to test side effects.
     */
    setMockActions: (implementation: MockActionImpl<A>) => MockStoreAction<S, A, F, P, DS>;
    /**
     * If action is asynchronous, mock the getPromise call to be resolved with specified object.
     */
    promiseResolves: (res: any) => MockStoreAction<S, A, F, P, DS>;
    /**
     * If action is asynchronous, mock the getPromise call to be rejected with specified error.
     */
    promiseRejects: (err: Error) => MockStoreAction<S, A, F, P, DS>;
    /**
     * Executes passed function to test state and/or props
     */
    test: (f: (state: S & DS, props: P) => void) => MockStoreAction<S, A, F, P, DS>;
    /**
     * Calls the action with specified parameters.
     * @returns a promise with state/props/actions to assert
     */
    call: (...args: Parameters<F>) => Promise<MockResult<S, A, P, DS>>;
};
type MockStore<S, A extends DecoratedActions, P, DS> = {
    getInitialState: (p: P) => S;
    /**
     * Creates a new store with specified state.
     */
    setState: (state: S) => MockStore<S, A, P, DS>;
    /**
     * Creates a new store with specified props.
     */
    setProps: (props: P) => MockStore<S, A, P, DS>;
    /**
     * Creates a new store using store state overriden by specified state.
     */
    setPartialState: (state: Partial<S>) => MockStore<S, A, P, DS>;
    /**
     * Creates a new store using store props overriden by specified props.
     */
    setPartialProps: (props: Partial<P>) => MockStore<S, A, P, DS>;
    /**
     * Set implementations to some actions to test side effects.
     */
    setMockActions: (implementation: MockActionImpl<A>) => MockStore<S, A, P, DS>;
    /**
     * Executes passed function to test state and/or props
     */
    test: (f: (state: S & DS, props: P) => void) => MockStore<S, A, P, DS>;
    /**
     * Test options.onMount
     * @deprecated Use init() instead
     */
    onMount: (props: Partial<P>) => MockResultWithTest<S, A, P, DS>;
    /**
     * Test state and side effect actions after inbound props have changed.
     */
    onPropsChange: (props: Partial<P>, init?: boolean) => MockResultWithTest<S, A, P, DS>;
    /**
     * Test store at initialization time:
     * - options.onPropsChange with onMount set to true
     * - options.onMount
     */
    onInit: (props?: Partial<P>) => MockResultWithTest<S, A, P, DS>;
    /** @internal */
    onPropsChangeImpl: (newStateRef: Ref<S>, newPropsRef: Ref<P>, newDerivedStateRef: Ref<DerivedState<DS>>, newActionsRef: Ref<StoreActions<S, A, P, DS, S>>, setState: SetStateFunc<S, A>, init?: boolean, deferred?: boolean) => MockResult<S, A, P, DS>;
    getAction: <K extends keyof A>(name: K) => MockStoreAction<S, A, A[K], P, DS>;
};
export declare function createMockFromStore<S, A extends DecoratedActions, P, DS>(store: StoreApi<S, A, P, DS>, props?: P): MockStore<S, A, P, DS>;
export declare function createMockStore<S, A extends DecoratedActions, P, DS>(config: StoreConfig<S, A, P, DS>, props?: P): MockStore<S, A, P, DS>;
export declare function createMockStoreV6<S, A extends DecoratedActions, P = {}, DS = {}>(getInitialState: (p: P) => S, actions: StoreActions<S, A, P, DS>, props?: P, options?: StoreOptions<S, A, P, DS>, mockActions?: MockActionImpl<A>): MockStore<S, A, P, DS>;
/**
 * Set the mock factory. Each mock action will be created using this factory.
 * @param factory the mock factory
 */
export declare function setMockFactory(factory: (impl?: (...args: any[]) => any) => any): void;
export declare class ActionError<S = any, P = any, A = any> extends Error {
    sourceError: Error;
    prevState: S;
    state: S;
    props: P;
    actions: MockActions<A, any>;
    constructor(sourceError: Error, prevState: S, state: S, props: P, actions: MockActions<A, any>);
}
export declare function createMockStoreAction<S, A extends DecoratedActions, F extends (...args: any[]) => any, P, DS>(state: S, actionName: keyof A, actions: StoreActions<S, A, P, DS>, props: P, promiseRes: Promise<F> | Error, options: StoreOptions<S, A, P, DS>, mockActions: Partial<Record<keyof A, (...args: any[]) => any>>): MockStoreAction<S, A, F, P, DS>;
export {};
