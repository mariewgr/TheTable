import type { DecoratedActions, MiddlewareFactory } from './types';
import { ConflictPolicy } from './types';
import { setGlobalConfig } from './index';
import type { AdvancedSynchAction, AsynchActionPromiseGet, StateDecoratorAction, StateDecoratorActions, StateDecoratorOptions, AsynchActionPromise, SynchAction, LoadingMap, LoadingProps, LoadingMapParallelActions, AsynchAction } from './v5_types';
export type { AdvancedSynchAction, AsynchActionPromiseGet, StateDecoratorAction, StateDecoratorActions, StateDecoratorOptions, AsynchActionPromise, SynchAction, LoadingMap, LoadingMapParallelActions, LoadingProps, ConflictPolicy, setGlobalConfig, };
/**
 * Type guard function to test if an action is a asynchronous action.
 */
export declare function isAsyncAction<S, F extends (...args: any[]) => any, A, P>(action: StateDecoratorAction<S, F, A, P>): action is AsynchAction<S, F, A, P>;
/**
 * Type guard function to test if an action is a asynchronous action.
 */
export declare function isAsyncPromiseGetAction<S, F extends (...args: any[]) => any, A, P>(action: StateDecoratorAction<S, F, A, P>): action is AsynchActionPromiseGet<S, F, A, P>;
/**
 * Type guard function to test if an action is a synchronous action.
 */
export declare function isSyncAction<S, F extends (...args: any[]) => any, A, P>(action: StateDecoratorAction<S, F, A, P>): action is SynchAction<S, F, P>;
/**
 * Type guard function to test if an action is a synchronous action.
 */
export declare function isAdvancedSyncAction<S, F extends (...args: any[]) => any, A, P>(action: StateDecoratorAction<S, F, A, P>): action is AdvancedSynchAction<S, F, A, P>;
declare function useStateDecorator<S, A extends DecoratedActions, P>(getInitialState: (props: P) => S, actions: StateDecoratorActions<S, A, P>, props: P, options?: StateDecoratorOptions<S, A, P>, middlewares?: MiddlewareFactory<S, A, P>[]): {
    state: S & {};
    actions: A;
    loading: boolean;
    loadingMap: import("./types").LoadingMap<A>;
    loadingParallelMap: import("./types").LoadingParallelMap<A>;
    abortAction: (actionName: keyof A, promiseId?: string) => boolean;
};
export default useStateDecorator;
/**
 * Hook to execute a function when hook is mounted.
 * @param onMount function to execute on the hook nount
 */
export declare function useOnMount(onMount: () => any): void;
/**
 * Hook to execute a function when hook is unmounted.
 * @param onUnMount function to execute on the hook nount
 */
export declare function useOnUnmount(onUnmount: () => void, propList?: any[]): void;
/**
 * Hook to execute a function when hook is unmounted.
 * @param onUnMount function to execute on the hook nount
 */
export declare function useOnUnload(onUnload: () => void): void;
